{
    "collab_server" : "",
    "contents" : "# V_WS_hyp_test comuputes the 1-alpha qunatile of the beta * chi-squared distribution with nu\n#   degrees of freedom, where beta and nu are obtained from a Welch-Satterthwaite approximation\n#   of the test statistic V_K. This quantile is used to conduct an approximate size alpha test\n#   of the hypothesis H'_0_K.\n# Input: f_data = the functional data matrix with functions in columns\n#        K = specifies the range of lags 1:K for the test statistic V_K\n#        alpha = the significance level to be used in the hypothesis test\n#        M = optional argument specifying the sampling size in the related Monte Carlo method\n#        low_disc = boolean value specifiying whether or not to use low-discrepancy sampling\n#                   for the Monte-Carlo method (only Sobol Sampling is currently supported)\n# Output: scalar value of the 1-alpha quantile of the beta * chi-square distribution with nu\n#         degrees of freedom (which approximates V_K)\nV_WS_quantile <- function(f_data, K, alpha=0.05, M=NULL, low_disc=FALSE) {\n  mean_V_K <- mean_hat_V_K(f_data, K)\n  var_V_K <- variance_hat_V_K(f_data, K, M=M, low_disc=low_disc)\n  beta <- var_V_K / (2 * mean_V_K)\n  nu <- 2 * (mean_V_K^2) / var_V_K\n  quantile <- beta * qchisq(1 - alpha, nu)\n  statistic <- t_statistic_V(f_data, K)\n  p_val <- pchisq(statistic / beta, nu, lower.tail = FALSE)\n  list(statistic = statistic, quantile = quantile, p_value = p_val)\n}\n\nV_WS_quantile_iid <- function(f_data, K, alpha=0.05) {\n  mean_V_K <- mean_hat_V_K_iid(f_data, K)\n  var_V_K <- variance_hat_V_K_iid(f_data, K)\n  beta <- var_V_K / (2 * mean_V_K)\n  nu <- 2 * (mean_V_K^2) / var_V_K\n  quantile <- beta * qchisq(1 - alpha, nu)\n  statistic <- t_statistic_V(f_data, K)\n  p_val <- pchisq(statistic / beta, nu, lower.tail = FALSE)\n  list(statistic = statistic, quantile = quantile, p_value = p_val)\n}\n\n# Q_WS_hyp_test comuputes the 1-alpha qunatile of the beta * chi-squared distribution with nu\n#   degrees of freedom, where beta and nu are obtained from a Welch-Satterthwaite approximation\n#   of the test statistic Q_h. This quantile is used to conduct an approximate size alpha test\n#   of the hypothesis H_0_h.\n# Input: f_data = the functional data matrix with functions in columns\n#        lag = specifies the lag used for the test statistic Q_h\n#        alpha = the significance level to be used in the hypothesis test\n#        M = optional argument specifying the sampling size in the related Monte Carlo method\n#        low_disc = boolean value specifiying whether or not to use low-discrepancy sampling\n#                   for the Monte-Carlo method (only Sobol Sampling is currently supported)\n# Output: scalar value of the 1-alpha quantile of the beta * chi-square distribution with nu\n#         degrees of freedom (which approximates Q_h).\nQ_WS_quantile <- function(f_data, lag, alpha=0.05, M=NULL, low_disc=FALSE) {\n  mean_Q_h <- mean_hat_Q_h(f_data, lag)\n  var_Q_h <- variance_hat_Q_h(f_data, lag, M=M, low_disc=low_disc)\n  beta <- var_Q_h / (2 * mean_Q_h)\n  nu <- 2 * (mean_Q_h^2) / var_Q_h\n  quantile <- beta * qchisq(1 - alpha, nu)\n  statistic <- t_statistic_Q(f_data, lag)\n  p_val <- pchisq(statistic / beta, nu, lower.tail = FALSE)\n  list(statistic = statistic, quantile = quantile, p_value = p_val)\n}\n\n# Q_WS_quantile_iid computes the size alpha test of the hypothesis H_0_h using the WS\n#   Approximation under the assumption that the data follows a strong white noise.\n# Input: f_data = the functional data matrix with functions in columns\n#        alpha = the significance level to be used in the hypothesis test\n# Output: scalar value of the 1-alpha quantile of the beta * chi-square distribution with nu\n#         degrees of freedom (which approximates Q_h) (computed under a strong white noise\n#         assumption).\nQ_WS_quantile_iid <- function(f_data, alpha=0.05) {\n  mean_Q_h <- mean_hat_Q_h_iid(f_data)\n  var_Q_h <- variance_hat_Q_h_iid(f_data)\n  beta <- var_Q_h / (2 * mean_Q_h)\n  nu <- 2 * (mean_Q_h^2) / var_Q_h\n  quantile <- beta * qchisq(1 - alpha, nu)\n  statistic <- t_statistic_Q(f_data, lag = 1)\n  p_val <- pchisq(statistic / beta, nu, lower.tail = FALSE)\n  list(p_value = p_val, quantile = quantile, statistic = statistic)\n}\n\n\n#' Compute size alpha single-lag hypothesis test under weak or strong white noise assumption\n#'\n#' \\code{Q_WS_hyp_test} Computes the size alpha test of a single lag hypothesis under a weak white noise\n#' or strong white noise assumption using a Welch-Satterthwaite Approximation.\n#'\n#' @param f_data the functional data matrix with observed functions in the columns\n#' @param lag the lag to use to compute the single lag test statistic\n#' @param alpha the significance level to be used in the hypothesis test\n#' @param iid boolean value, if given TRUE, the hypothesis test will use a strong-white noise assumption.\n#' By default is FALSE, in which the hypothesis test will use a weak-white noise assumption.\n#' @param M Number of samples to take when applying a Monte-Carlo approximation\n#' @param low_disc Boolean value indicating whether or not to use low-discrepancy sampling in the Monte\n#' Carlo method. Note, low-discrepancy sampling will yield deterministic results.\n#' @param bootstrap boolean value, if given TRUE, the hypothesis test is done by approximating the\n#' limiting distribution of the test statistic via a block bootstrap algorithm. FALSE by deafult.\n#' @param block_size the block size to be used in the block bootstrap method (in each bootstrap sample).\n#' 10 by default.\n#' @param straps the number of bootstrap samples to take; 300 by default\n#' @param moving boolean value; determines whether or not the block bootstrap should be moving\n#' @return A list containing the p-value, the quantile, and a boolean value indicating whether or not the\n#' hypothesis is rejected.\n#'\n#' @import stats\nQ_WS_hyp_test <- function(f_data, lag, alpha=0.05, iid=FALSE,\n                          M=NULL, low_disc=FALSE, bootstrap=FALSE,\n                          block_size='adaptive', straps=300, moving = FALSE) {\n  statistic <- t_statistic_Q(f_data, lag)\n  if (bootstrap == TRUE) {\n    if (block_size == 'adaptive') {\n      block_size <- ceiling(adaptive_bandwidth(f_data, kernel = 'Bartlett'))\n    }\n    bootsraps <- list()\n    bootstrap_samples <- block_bootsrap(f_data, block_size, B = straps, moving = moving)\n    stats_distr <- lapply(bootstrap_samples, t_statistic_Q, lag=lag)\n    statistic <- t_statistic_Q(f_data, lag=lag)\n    quantile <- quantile(as.numeric(stats_distr), 1 - alpha)\n    p_value <- sum(statistic > stats_distr) / length(stats_distr)\n    list(p_value = as.numeric(p_value), quantile = as.numeric(quantile),\n         statistic = as.numeric(statistic), block_size = block_size)\n  } else if (iid == FALSE) {\n    results <- Q_WS_quantile(f_data, lag, alpha=alpha, M=M, low_disc=low_disc)\n    statistic <- results$statistic\n    quantile <- results$quantile\n    p_val <- results$p_val\n    reject <- statistic > quantile\n    list(p_value = p_val, quantile = quantile, reject = reject)\n  } else {\n    results <- Q_WS_quantile_iid(f_data, alpha=alpha)\n    statistic <- results$statistic\n    quantile <- results$quantile\n    p_val <- results$p_val\n    reject <- statistic > quantile\n    list(p_value = p_val, quantile = quantile, reject = reject)\n  }\n}\n",
    "created" : 1560277948017.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1243858458",
    "id" : "A7740B29",
    "lastKnownWriteTime" : 1560277964,
    "last_content_update" : 1560277964849,
    "path" : "~/wwntests/R/hypothesis_quantiles.R",
    "project_path" : "R/hypothesis_quantiles.R",
    "properties" : {
        "docOutlineVisible" : "1",
        "tempName" : "Untitled1"
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}