{
    "collab_server" : "",
    "contents" : "# spectral_t_statistic computes the spectral density operator based test statistic of the functional\n#   data f_data.\n# Input: f_data = the functional data matrix with observed functions in columns\n#        kernel = the kernel function to use. The currently supported kernels are 'Bartlett', 'Parzen',\n#                 and 'Daniell'. The default kernel is 'Bartlett'.\n#        bandwidth = specifies the bandwidth to use. Currently admitted arguments are positive\n#                    integers, 'static' which computes the bandwith p via p = n^(1/(2q+1)) where\n#                    n is the sample size and q is the kernel order, or 'adaptive' which uses a\n#                    bandwith selection method that is based on the functional data.\n# Output: scalar value of the spectral density based test statistic.\nspectral_t_statistic <- function(f_data, kernel = 'Bartlett', bandwidth = 'adaptive') {\n  J <- NROW(f_data)\n  N <- NCOL(f_data)\n  kernel_string <- kernel\n  if (kernel == 'Bartlett') {\n    kernel <- bartlett_kernel\n    kernel_order <- 1\n  } else if (kernel == 'Parzen') {\n    kernel <- parzen_kernel\n    kernel_order <- 2\n  } else if (kernel == 'Daniell') {\n    kernel <- daniell_kernel\n    kernel_order <- 2\n  } else {\n    stop(\"This kernel is not supported. Please see the documentation for supported kernel functions.\")\n  }\n  if (bandwidth == 'static') {\n    bandwidth <- N^(1 / (2 * kernel_order + 1))\n  } else if (bandwidth == 'adaptive') {\n    bandwidth <- max(2, adaptive_bandwidth(f_data, kernel_string))\n  } else if (!is.numeric(bandwidth)) {\n    stop(\"Please see the documentation for valid bandwith arguments.\")\n  }\n  data_inner_prod <- crossprod(f_data) / J # why is this what we want...\n  C_hat_HS_norm <- numeric(0)\n  for (j in 0:(N-1)) {\n    C_hat_HS_norm[j+1] <- N^(-2) * sum(data_inner_prod[(j+1):N, (j+1):N] * data_inner_prod[1:(N-j), 1:(N-j)])\n  }\n  kernel_vals <- sapply(1:(N-1) / bandwidth, kernel)\n  spectral_distance_Q_sq <- 2 * sum((kernel_vals^2) * C_hat_HS_norm[-1])\n  C_n_k <- sum( (1 - 1:(N-1)/N) * kernel_vals^2 )\n  D_n_k <- sum( (1 - 1:(N-2)/N) * (1 - 2:(N-1)/N) * kernel_vals[-(N-1)]^4 )\n  sigma_squared_hat <- sum(diag(data_inner_prod)) / N\n\n  t_stat_term <- sigma_squared_hat^(-2) * C_hat_HS_norm[1] * sqrt(2 * D_n_k) # for convenience\n  untrans_num <- 2^(-1) * N * sigma_squared_hat^(-2) * spectral_distance_Q_sq\n\n  ### TODO: add case for when H is not R. This is denoted by const in original codebase\n  beta <- 1 - (2/3) * sum(kernel_vals^2) * sum(kernel_vals^6) / (sum(kernel_vals^4)^2)\n  t_stat <- ((2^(-1) * N * sigma_squared_hat^(-2) * spectral_distance_Q_sq)^beta -\n    (C_n_k^beta + 2^(-1) * beta * (beta - 1) * C_n_k^(beta-2) * t_stat_term^2)) / (beta * C_n_k^(beta-1) * t_stat_term)\n  list(stat = t_stat, band = bandwidth)\n}\n\n\n# adaptive_bandwidth computes the \"optimal\" bandwidth using a bandwidth selection method based on the\n#   spectral density operator which adapts to the functional data.\n# Input: f_data = the functional data matrix with observed functions in columns\n#        kernel = the kernel function to use. The currently supported kernels are 'Bartlett', 'Parzen',\n#                 and 'Daniell'. The default kernel is 'Bartlett'.\n# Output: a scalar value of the \"optimal\" data-adapted bandwidth.\nadaptive_bandwidth <- function(f_data, kernel) {\n  J <- NROW(f_data)\n  N <- NCOL(f_data)\n  if (kernel == 'Bartlett') {\n    kernel <- bartlett_kernel\n    order <- 1\n    xi <- 1\n    kern_int <- 2 / 3\n  } else if (kernel == 'Parzen') {\n    kernel <- parzen_kernel\n    order <- 2\n    xi <- 6\n    kern_int <- 151 / 280\n  } else if (kernel == 'Daniell') {\n    kernel <- daniell_kernel\n    order <- 2\n    xi <- (pi^2) / 6\n    kern_int <- 1\n  } else {\n    stop('Please see the documentation for supported kernels.')\n  }\n  data_inner_prod <- crossprod(f_data) / (N * J)\n  C_hat_HS <- numeric(0)\n  for (j in 0:(N-1)) {\n    C_hat_HS[j+1]<-sum(data_inner_prod[(j+1):N,(j+1):N] * data_inner_prod[1:(N-j),1:(N-j)])\n  }\n  initial_band_q <- 4 * N^(1 / (2*order +1))\n  k_n_j_q <- kernel(1:(N-1) / initial_band_q)\n  initial_band_0 <- initial_band_q / 4\n  k_n_j_0 <- kernel(1:(N-1) / initial_band_0)\n  Q_hat_sq <- 2 * sum(k_n_j_0^2 * C_hat_HS[-1])\n  Q_hat_sq <- Q_hat_sq + sum(C_hat_HS[0])\n  Term2 <- Q_hat_sq\n  Term1 <- 2 * sum(k_n_j_q^2 * ((1:(N-1))^(2*order)) * C_hat_HS[-1])\n  C_hat_TR <- numeric(0)\n  for (j in 0:(N-1)) {\n    C_hat_TR[j+1] <- sum(data_inner_prod[1:(N-j), (j+1):N])\n  }\n  trace <- 2 * sum(k_n_j_0^2 * C_hat_TR[-1])\n  Term3 <- trace + sum(C_hat_TR[1])\n  band_constant <- (2 * order * xi^2 * Term1 / (kern_int * (Term2 + Term3)))^(1/(2*order + 1))\n  band_constant * N^(1 / (2*order + 1))\n}\n\n",
    "created" : 1560277879638.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "957519661",
    "id" : "BA1AEC05",
    "lastKnownWriteTime" : 1559645569,
    "last_content_update" : 1559645569,
    "path" : "~/wwntests/R/spectral_test_statistic.R",
    "project_path" : "R/spectral_test_statistic.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}