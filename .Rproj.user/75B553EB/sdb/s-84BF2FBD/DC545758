{
    "collab_server" : "",
    "contents" : "#' Compute Functional Hypothesis Tests\n#'\n#' \\code{fport_test} Computes a variety of functional portmanteau hypothesis tests.\n#'\n#' @param f_data The functional data matrix with observed functions in the columns.\n#' @param test A string specifying the hypothesis test. Currently available tests are referred to by their\n#' string handles: \"single-lag\", \"multi-lag\", \"spectral\", \"independence\", and \"imhof\". Please see the Details\n#' section of the documentation, or the vignette, for a short overview of the available tests. For a more\n#' complete treatment of these hypothesis tests, please consult the references.\n#' @param lag Positive integer value. Only used for the \"single-lag\", \"multi-lag\", \"independence\", and \"imhof\" tests.\n#' This parameter specifies the single lag, or maximum lag, to be used by the specified test.\n#' @param iid Only used for the \"single-lag\" and \"multi-lag\" tests. A Boolean value, FALSE by default. If given TRUE,\n#' the hypothesis test will use a strong-white noise assumption (instead of a weak-white noise assumption).\n#' @param M Only used for the \"single-lag\" and \"multi-lag\" tests. A positive Integer. Determines the number of\n#' Monte-Carlo simulations employed in the Welch-Satterthwaite approximation of the limiting distribution of the\n#' test statistic.\n#' @param low_disc Only used for the \"single-lag\" and \"multi-lag\" tests. A Boolean value, FALSE by default.\n#' If given TRUE, uses low-discrepancy sampling in the Monte-Carlo method. Note, low-discrepancy sampling will\n#' yield deterministic results. Requires the 'fOptions' package.\n#' @param kernel Only used for the \"spectral\" test. A String, 'Bartlett' by default. Specifies the kernel to be\n#' used in the \"spectral\" test. Currently supported kernels are the 'Bartlett', 'Parzen', and 'Daniell' kernels.\n#' @param bandwidth Only used for the \"spectral\" test. Either a String or a positive Integer value, 'adaptive' by\n#' default. Determines the bandwidth (or lag-window) to be used for the test. If given the string handle is\n#' 'adaptive', the bandwidth is computed via a bandwidth selection method which aims to minimize the integrated\n#' normed error of the spectral density operator. If the given string handle is 'static', the bandwidth is\n#' computed to be n^(1/(2q + 1)), where n is the sample size and q is the kernel order. If a positive integer\n#' is given, that will be the bandwidth that is used.\n#' @param components Only used for the \"independence\" test. A positive Integer value. Determines the number of\n#' functional principal components to compute.\n#' @param bootstrap Only used for the \"single-lag\" test. A Boolean value, FALSE by default. If given TRUE, the\n#' hypothesis test is evaluated by approximating the limiting distribution of the test statistic via a block\n#' bootstrapping process.\n#' @param block_size Only used for the \"single-lag\" test and if 'bootstrap' = TRUE. A positive Integer value,\n#' with the default value being computed via the adaptive bandwith selection method in the \"spectral\" test.\n#' Determines the block size (of each block in each bootstrap sample) if the test is being bootstrapped.\n#' @param straps Only used for the \"single-lag\" test and if 'bootstrap' = TRUE. A positive Integer with a\n#' default value of 300. Determines the number of bootstrap samples to take if the test is being bootstrapped.\n#' @param moving Only used for the \"single-lag\" test and if 'bootstrap' = TRUE. A Boolean value, FALSE by\n#' default If given TRUE, the performed block bootstrap will be moving rather than stationary.\n#' @param alpha Positive numeric value. The significance level to be used in the specified hypothesis test.\n#' The default value is 0.05. Note, the significance value is only ever used to compute the 1-alpha quantile\n#' of the limiting distribution of the specified test's test statistic.\n#' @param complete_test A Boolean value, FALSE by default. If TRUE, the function requires no other paramters\n#' other than f_data, and will return a table with a signle column containing p_values and an array of tests\n#' contained in the rows.\n#' @param suppress_raw_output A Boolean value, FALSE by default. If given TRUE, the function will not return a\n#' list containing the p-value, quantile and statistic, and instead only prints output to the console.\n#' @param suppress_print_output Boolean value, FALSE by default. If TRUE, the function will not print any\n#' output to the console.\n#' @details The \"single-lag\" portmanteau test is based on the sample autocovariance function computed from the\n#' functional data. This test asseses the significance of lagged autocovariance operators at a single, user-specified\n#' lag h. More specifically, it tests the null hypothesis that the lag-h autocovariance operator is equal to 0.\n#' This test is desgined for stationary functional time-series, and is valid under conditional heteroscedasticity\n#' conditions.\n#' The required parameter for this test are 'lag', which determines the lag at which the test is evaluated. If this\n#' parameter is left blank, it will take a default of 1.\n#' The optional parameters for this test are 'iid', 'M', 'low_disc', 'bootstrap', 'block_size', 'straps', 'moving',\n#' and 'alpha'.\n#'\n#' The \"multi-lag\" portmanteau test is also based on the sample autocovariance function computed from the functional\n#' data. This test asseses the cumulative significance of lagged autocovariance operators, up to a user-selected\n#' maximum lag K. More specifically, it tests the null hypothesis that the first K lag-h autocovariance operators\n#' (h going from 1 to K) is equal to 0. This test is desgined for stationary functional time-series, and is valid\n#' under conditional heteroscedasticity conditions.\n#' The required parameter for this test is 'lag', which determines the maxmimum lag at which the test is evaluated.\n#' If this parameter is left blank, it will take a default of 20.\n#' The optional parameters for this test are 'iid', 'M', 'low_disc', 'bootstrap', 'block_size', 'straps', 'moving',\n#' and 'alpha'.\n#'\n#' The \"spectral\" portmanteau test is based on the spectral density operator. It essentially measures the proximity of a\n#' functional time series to a white noise - the constant spectral density operator of an uncorrelated series.\n#' Unlike the \"single-lag\" and \"multi-lag\" tests, this test is not for general white noise series, and may not hold\n#' under functional conditionally heterscedastic assumptions.\n#' The optional parameters for this test are 'kernel', 'bandwidth', and 'alpha'.\n#'\n#' The \"independence\" portmanteau test is a test of independence and identical distributuion based on a dimensionality\n#' reduction by projecting the data onto the most important functional principal components. It is based on the\n#' resulting lagged cross-variances. This test is not for general white noise series, and may not hold under\n#' functional conditionally heteroscedastic assumptions.\n#' The required parameters for this test are 'lag' and 'components'. The 'lag' parameter determines the maximum lag at\n#' which the test is evaluated. The 'components' parameter determines the number of the most important principal\n#' components to use (importance is determined by the proportion of the variance that is explained the by the\n#' individual principal component.)\n#'\n#' The \"imhof\" portmanteau test is a variant of the \"single-lag\" test. While the \"single-lag\" test computes the\n#' limiting distribution of the test statistic via a Welch-Satterthwaite approximation, the \"imhof\" test directly\n#' computes the coefficents of the quadratic form in Normal variables which the test statistic converges too as\n#' the sample size goes to infinity. We warn the user that this test is extremely computationally expensive, and\n#' is only recommended for small datasets as a means of cross-verification against the single-lag test.\n#' The required parameter for this test is 'lag', which determines the lag at which the test is evaluated.\n#' The \"imhof\" test requires the \"tensorA\" and \"CompQuadForm\" packages.\n#' @return A list containing the test statistic, the 1-alpha quantile of the limiting distribution, and the\n#' p-value computed from the specified hypothesis test. Also prints output containing a short description of\n#' the test, the p-value, and additional information about the test. If 'complete-test' = TRUE, will return\n#' a 1-column table instead containing the p-values for a variety of tests, which are given short descriptions\n#' in the index of the table.\n#'\n#' @references\n#' Kokoszka P., & Rice G., & Shang H.L. (2017). Inference for the autocovariance of a functional time series\n#' under conditional heteroscedasticity. Journal of Multivariate Analysis, 162, 32-50.\n#'\n#' Characiejus V., & Rice G. (2019). A general white noise test based on kernel lag-window estimates of the\n#' spectral density operator. Econometrics and Statistics, submitted.\n#'\n#' Gabrys R., & Kokoszka P. (2007). Portmanteau Test of Independence for Functional Observations.\n#' Journal of the American Statistical Association, 102:480, 1338-1348, DOI: 10.1198/016214507000001111.\n#'\n#' Zhang X. (2016). White noise testing and model diagnostic checking for functional time series.\n#' Journal of Econometrics, 194, 76-95.\n#'\n#' @examples\n#' b <- brown_motion(250, 50)\n#' fport_test(b, test = 'single-lag', lag = 10)\n#' fport_test(b, test = 'multi-lag', lag = 10, alpha = 0.01)\n#' fport_test(b, test = 'single-lag', lag = 1, M = 250, low_disc = TRUE)\n#' fport_test(b, test = 'multi-lag', lag = 20, low_disc = TRUE)\n#' fport_test(b, test = 'spectral', kernel = 'Bartlett', bandwidth = 'static', alpha = 0.05)\n#' fport_test(b, test = 'spectral', alpha = 0.1, kernel = 'Parzen', bandwidth = 'adaptive')\n#' fport_test(b, test = 'spectral', kernel = 'Daniell', bandwidth = 2)\n#' fport_test(b, test = 'independence', components = 3, lag = 3)\n#'\n#' @export\n#' @import stats\nfport_test <- function(f_data, test = 'multi-lag', lag=NULL, iid=FALSE, M=NULL,\n                       low_disc=FALSE, kernel = \"Bartlett\", bandwidth = \"adaptive\",\n                       components = 3, bootstrap=FALSE, block_size = 5, moving=FALSE,\n                       straps = 300, alpha=0.05, complete_test=FALSE,\n                       suppress_raw_output = FALSE, suppress_print_output = FALSE) {\n  tests = c('single-lag', 'multi-lag', 'spectral', 'independence', 'imhof')\n  if (test == 'multi-lag' & is.null(lag) & complete_test==FALSE) {\n    warning(\"You did not specify a maximum lag for the multi-lag test. We use a default of lag = 20\")\n    lag = 20\n  }\n  if (test == 'single-lag' & is.null(lag) & complete_test==FALSE) {\n    warning(\"You did not specify a maximum lag for the single-lag test. We use a default of lag = 1\")\n    lag = 1\n  }\n  if (!(test %in% tests)) {\n    stop(\"Please see the documentation for available tests.\")\n  }\n  if (!is.matrix(f_data)) {\n    stop(\"Invalid arguments, functional data f_data must be passed in matrix form.\")\n  }\n  if (!is.null(lag)) {\n    if (!all.equal(lag, as.integer(lag)) | lag <= 0) {\n      stop(\"Invalid arguments, lag must be a positive integer for the single-lag and multi-lag tests.\")\n    }\n  }\n  if (alpha < 0 | alpha > 1) {\n    stop(\"Invalid arguments, the significance level alpha must be between 0 and 1.\")\n  }\n  if (!is.logical(iid) | !is.logical(low_disc)) {\n    stop(\"Invalid arguments, the iid and low_disc parameters must be logical values.\")\n  }\n  if (!is.null(M)) {\n    if (!all.equal(M, as.integer(M)) | M < 0) {\n      stop(\"Invalid arguments, M must be a positive integer or NULL.\")\n    }\n  }\n  if (test == 'imhof') {\n    print('This test is very computationally expensive. It is not recommended for large datasets.')\n  }\n  iid_error = base::simpleError(\"When iid = true, this function does not use Monte Carlo methods,\nand thus also does not support low-discrepancy sequence sampling or parallelization. Please change the parameters.\")\n  if ((iid == TRUE) & ((low_disc == TRUE) | (!is.null(M)))) {\n    stop(iid_error)\n  }\n  if (complete_test == TRUE) {\n    m <- as.table(matrix(0, ncol = 1, 10))\n    colnames(m) <- c('p_value')\n    rownames(m) <- c('single-lag, lag = 1', 'single-lag, lag = 2',\n                     'single-lag, lag = 3', 'multi-lag, lag = 5',\n                     'multi-lag, lag = 10', 'multi-lag, lag = 20',\n                     'spectral, static bandwidth',\n                     'spectral, adaptive bandwidth',\n                     'independence, 3 components, lag = 3',\n                     'independence, 16 components, lag = 10')\n    m[1] <- fport_test(f_data, test = 'single-lag', lag = 1)$p_value\n    m[2] <- fport_test(f_data, test = 'single-lag', lag = 2)$p_value\n    m[3] <- fport_test(f_data, test = 'single-lag', lag = 3)$p_value\n\n    m[4] <- fport_test(f_data, test = 'multi-lag', lag = 5)$p_value\n    m[5] <- fport_test(f_data, test = 'multi-lag', lag = 10)$p_value\n    m[6] <- fport_test(f_data, test = 'multi-lag', lag = 20)$p_value\n\n    m[7] <- fport_test(f_data, test = 'spectral',\n                       bandwidth = 'static')$p_value\n    m[8] <- fport_test(f_data, test = 'spectral',\n                       bandwidth = 'adaptive')$p_value\n\n    m[9] <- fport_test(f_data, test = 'independence',\n                       components = 3, lag = 3)$p_value\n\n    m[10] <- fport_test(f_data, test = 'independence',\n                        components = 16, lag = 10)$p_value\n    m\n  } else if (test == 'multi-lag') {\n    multi_lag_test(f_data, lag, M=M, low_disc = low_disc, iid=iid,\n                   suppress_raw_output = suppress_raw_output,\n                   suppress_print_output = suppress_print_output)\n  } else if (test == 'single-lag') {\n    single_lag_test(f_data, lag, alpha=0.05, iid=FALSE,\n                    M=NULL, low_disc=FALSE, bootstrap=FALSE,\n                    block_size=10, straps=300, moving = FALSE,\n                    suppress_raw_output = suppress_raw_output,\n                    suppress_print_output = suppress_print_output)\n  } else if (test == 'spectral') {\n    spectral_test(f_data, kernel = kernel, bandwidth = bandwidth, alpha = alpha,\n                  suppress_raw_output=suppress_raw_output,\n                  suppress_print_output = suppress_print_output)\n  } else if (test == 'independence') {\n    independence_test(f_data, components = components, lag = lag,\n                      suppress_raw_output = suppress_raw_output,\n                      suppress_print_output = suppress_print_output)\n  } else if (test == 'imhof') {\n    imhof_test(f_data, lag)\n  }\n}\n\n\n#' Plot Confidence Bounds of Estimated Functional Autocorrelation Coefficients\n#'\n#' \\code{autocorrelation_coeff_plot} Computes the 1-alpha confidence bounds for the functional\n#' autocorrelation coefficients at lags h = 1:K under both weak white noise and strong white\n#' noise assumptions. It plots the coefficients as well as the bounds for all lags h = 1:K.\n#'\n#' @param f_data The functional data matrix with observed functions in the columns.\n#' @param K The maximum lag for which to compute the single-lag test (tests will be computed for lags\n#' h in 1:K).\n#' @param alpha Positive numeric Value. The significance level to be used in the specified hypothesis test.\n#' The default value is 0.05.\n#' @param M Positive Integer value. Determines the number of Monte-Carlo simulations employed in the\n#' Welch-Satterthwaite approximation of the limiting distribution of the test statistics, for each test.\n#' @param low_disc A Boolean value, FALSE by default. If given TRUE, uses low-discrepancy sampling in the\n#' Monte-Carlo method. Note, low-discrepancy sampling will yield deterministic results.\n#' Requires the 'fOptions' package.\n#' @details This function computes and plots autocorrelation coefficients at lag h, for h in 1:K. It also computes\n#' an estimated asymptotic 1 - alpha quantile of the single-lag test statistic, under the assumption that the series\n#' forms a weak white noise. Additionally, it computes a similar bound under the assumption the the series form a\n#' strong white noise. Please see the vignette or the references for a more complete treatment.\n#' @return Plot of the estimated autocorrelation coefficients for lags h in 1:K with the weak\n#' white noise 1-alpha confidence bound for each lag, as well as the constant strong white noise 1-alpha\n#' confidence bound.\n#'\n#' @references\n#' Kokoszka P., & Rice G., & Shang H.L. (2017). Inference for the autocovariance of a functional time series\n#' under conditional heteroscedasticity. Journal of Multivariate Analysis, 162, 32-50.\n#'\n#' @examples\n#' b <- brown_motion(75, 40)\n#' autocorrelation_coeff_plot(b)\n#' autocorrelation_coeff_plot(b, M = 200, low_disc = TRUE)\n#'\n#' @export\n#' @import sde\n#' @importFrom graphics legend lines par plot\nautocorrelation_coeff_plot <- function(f_data, K=20, alpha=0.05, M=NULL, low_disc=FALSE) {\n  if ((K < 1) | (K %% 1 != 0)) {\n    stop(\"The parameter 'K' must be a positive integer.\")\n  }\n  if ((alpha > 1) | (alpha < 0)) {\n    stop(\"The 'alpha' parameter must be a value between 0 and 1.\")\n  }\n  J = NROW(f_data)\n  coefficients = array(0, K)\n  B_h_bounds = array(0,K)\n  B_iid_bounds = array(0,K)\n  lags = 1:K\n  for (h in lags){\n    coefficients[h] <- autocorrelation_coeff_h(f_data, h)\n    B_h_bounds[h] <- B_h_bound(f_data, h, M=M, low_disc=low_disc)\n  }\n  par(mfrow=c(1,1))\n  plot(lags, coefficients, ylim=c(0,2 * max(coefficients)), type='h', xlab='Lag',\n         ylab='Autocorrelation Coefficient', main = 'Autocorrelation Bounds')\n  lines(B_h_bounds, col='blue', lty='dotted')\n  lines(rep(B_iid_bound(f_data), K), col='red', lty='solid')\n  legend('topleft',\n         legend=c('Estimated Autocorrelation Coefficients', 'GARCH Bound', 'IID Bound'),\n         col=c('black', 'blue', 'red'), lty=c('solid', 'dotted', 'solid'), cex=0.75)\n}\n",
    "created" : 1559645666239.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1030024105",
    "id" : "DC545758",
    "lastKnownWriteTime" : 1560208385,
    "last_content_update" : 1560208385402,
    "path" : "~/wwntests/R/master_functions.R",
    "project_path" : "R/master_functions.R",
    "properties" : {
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}