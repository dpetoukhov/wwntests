{
    "collab_server" : "",
    "contents" : "#' Compute the Single-Lag Hypothesis Test, Testing Weak White Noise Assumption\n#'\n#' \\code{single_lag_test} Computes the single-lag hypothesis test.\n#'\n#' @param f_data the functional data matrix with observed functions in the columns\n#' @param lag Positive integer value. The lag to use to compute the single lag test statistic\n#' @param alpha Positive numeric value. The significance level to be used in the hypothesis test.\n#' The default value is 0.05. Note, the significance value is only ever used to compute the 1-alpha quantile\n#' of the limiting distribution of the statistic.\n#' @param iid A Boolean value, FALSE by default. If given TRUE, the hypothesis test will use a strong-white\n#' noise assumption (instead of a weak-white noise assumption).\n#' @param M Positive integer value. Number of Monte-Carlo simulation for Welch-Satterthwaite approximation.\n#' @param low_disc A Boolean value, FALSE by default. If given TRUE, uses low-discrepancy sampling in the\n#' Monte-Carlo method. Note, low-discrepancy sampling will yield deterministic results.\n#' Requires the 'fOptions' package.\n#' @param bootstrap A Boolean value, FALSE by deafult. If given TRUE, the hypothesis test is done by\n#' approximating the limiting distribution of the test statistic via a block bootstrap process.\n#' @param block_size A positive Integer value, with the default value being computed via the adaptive\n#' bandwith selection method in the \"spectral\" test. Determines the block size (of each block in each\n#' bootstrap sample) if the test is being bootstrapped.\n#' @param straps A positive Integer, with a default value of 300. Determines the number of bootstrap samples\n#' to take if the test is being bootstrapped. Only used if 'bootstrap' == TRUE.\n#' @param moving A Boolean value, FALSE by default If given TRUE, the performed block bootstrap will be moving\n#' rather than stationary.\n#' @param suppress_raw_output Boolean value, FALSE by default. If TRUE, the function will not return the list\n#' contining the p-value, quantile, and statistic.\n#' @param suppress_print_output Boolean value, FALSE by default. If TRUE, the function will not print any\n#' output to the console.\n#' @details The \"single-lag\" portmanteau test is based on the sample autocovariance function computed from the\n#' functional data. This test asseses the significance of lagged autocovariance operators at a single,\n#' user-specified lag h. More specifically, it tests the null hypothesis that the lag-h autocovariance\n#' operator is equal to 0. This test is desgined for stationary functional time-series, and is valid under\n#' conditional heteroscedasticity conditions.\n#' @return A list containing the p-value, the quantile, and a boolean value indicating whether or not the\n#' hypothesis is rejected.\n#'\n#' @references\n#' Kokoszka P., & Rice G., & Shang H.L. (2017). Inference for the autocovariance of a functional time series\n#' under conditional heteroscedasticity. Journal of Multivariate Analysis, 162, 32-50.\n#'\n#' @examples\n#' f <- far_1_S(150, 50, S = 0.75)\n#' test_results1 <- single_lag_test(f, lag = 1)\n#' test_results2 <- single_lag_test(f, lag = 2, M=100)\n#'\n#' @import stats\n#' @export\nsingle_lag_test <- function(f_data, lag=1, alpha=0.05, iid=FALSE,\n                          M=NULL, low_disc=FALSE, bootstrap=FALSE,\n                          block_size='adaptive', straps=300, moving = FALSE,\n                          suppress_raw_output=FALSE, suppress_print_output=FALSE) {\n  if (bootstrap == TRUE & (iid == TRUE | low_disc == TRUE)) {\n    stop(\"Bootstrapping this test only requires the lag parameter\n         (and optionally, a significance level).\")\n  }\n  if (suppress_raw_output == TRUE & suppress_print_output == TRUE) {\n    stop(\"Current choice of parameters will produce no output. Atleast one of the parameters\n         'suppress_raw_output' or 'suppress_print_output' must be FALSE.\")\n  }\n  if (bootstrap == TRUE) {\n    results <- Q_WS_hyp_test(f_data, lag, alpha = alpha, bootstrap = TRUE, block_size = block_size,\n                             moving = moving, straps = straps)\n    if (suppress_print_output == FALSE) {\n      if (moving == TRUE) {\n        title_print <- sprintf(\" Moving Block Bootstrapped Single-Lag Test\\n\\n\")\n      } else if (moving == FALSE) {\n        title_print <- sprintf(\" Block Bootstrapped Single-Lag Test\\n\\n\")\n      }\n      test_type <- 'the series is a weak white noise\\n'\n      null_print <- sprintf(\"null hypothesis: %s\", test_type)\n      p_val_print <- sprintf(\"p-value = %f\\n\", results$p_value)\n      samp_print <- sprintf(\"sample size = %d\\n\", NCOL(f_data))\n      lag_print <- sprintf(\"lag = %d\\n\", lag)\n      boot_num <- sprintf(\"number of bootstrap samples = %d\\n\", straps)\n      block_sze <- sprintf(\"block size = %d\\n\\n\\n\", results$block_size)\n      cat(c(title_print, null_print, p_val_print, samp_print,\n            lag_print, boot_num, block_sze))\n    }\n    if (suppress_raw_output == FALSE) {\n      results[-4]\n    }\n  } else if (iid  == FALSE) {\n    results <- Q_WS_hyp_test(f_data, lag, alpha=alpha, M=M, low_disc=low_disc)\n    if (suppress_print_output == FALSE) {\n      title_print <- sprintf(\" Single-Lag Test\\n\\n\")\n      test_type <- 'the series is a weak white noise\\n'\n      null_print <- sprintf(\"null hypothesis: %s\", test_type)\n      p_val_print <- sprintf(\"p-value = %f\\n\", results$p_value)\n      samp_print <- sprintf(\"sample size = %d\\n\", NCOL(f_data))\n      lag_print <- sprintf(\"lag = %d\\n\\n\\n\", lag)\n      cat(c(title_print, null_print, p_val_print, samp_print,\n            lag_print))\n    }\n    if (suppress_raw_output == FALSE) {\n      results\n    }\n  } else if (iid == TRUE) {\n    results <- single_lag_test(f_data, iid = TRUE, alpha=alpha)\n    if (suppress_print_output == FALSE) {\n      title_print <- sprintf(\" Single-Lag Test (iid assumption)\\n\\n\")\n      test_type <- 'the series is a strong white noise\\n'\n      null_print <- sprintf(\"null hypothesis: %s\", test_type)\n      p_val_print <- sprintf(\"p-value = %f\\n\", results$p_value)\n      samp_print <- sprintf(\"sample size = %d\\n\", NCOL(f_data))\n      lag_print <- sprintf(\"lag = %d\\n\\n\\n\", lag)\n      cat(c(title_print, null_print, p_val_print, samp_print,\n            lag_print))\n    }\n    if (suppress_raw_output == FALSE) {\n      results\n    }\n  }\n}\n\n\n#' Compute the Multi-Lag Hypothesis Test, Testing Weak White Noise Assumption\n#'\n#' \\code{multi_lag_test} Computes the multi-lag hypothesis test.\n#'\n#' @param f_data the functional data matrix with observed functions in the columns\n#' @param lag Positive integer value. The lag to use to compute the single lag test statistic\n#' @param alpha Positive numeric value. The significance level to be used in the hypothesis test.\n#' The default value is 0.05. Note, the significance value is only ever used to compute the 1-alpha quantile\n#' of the limiting distribution of the statistic.\n#' @param iid A Boolean value, FALSE by default. If given TRUE, the hypothesis test will use a strong-white\n#' noise assumption (instead of a weak-white noise assumption).\n#' @param M Positive integer value. Number of Monte-Carlo simulation for Welch-Satterthwaite approximation.\n#' @param low_disc A Boolean value, FALSE by default. If given TRUE, uses low-discrepancy sampling in the\n#' Monte-Carlo method. Note, low-discrepancy sampling will yield deterministic results.\n#' Requires the 'fOptions' package.\n#' @param suppress_raw_output Boolean value, FALSE by default. If TRUE, the function will not return the list\n#' contining the p-value, quantile, and statistic.\n#' @param suppress_print_output Boolean value, FALSE by default. If TRUE, the function will not print any\n#' output to the console.\n#' @details The \"multi-lag\" portmanteau test is also based on the sample autocovariance function computed from the\n#' functional data. This test asseses the cumulative significance of lagged autocovariance operators, up to a\n#' user-selected maximum lag K. More specifically, it tests the null hypothesis that the first K lag-h autocovariance\n#' operators (h going from 1 to K) is equal to 0. This test is desgined for stationary functional time-series, and\n#' is valid under conditional heteroscedasticity conditions.\n#' @return A list containing the p-value, the quantile, and a boolean value indicating whether or not the\n#' hypothesis is rejected.\n#'\n#' @references\n#' Kokoszka P., & Rice G., & Shang H.L. (2017). Inference for the autocovariance of a functional time series\n#' under conditional heteroscedasticity. Journal of Multivariate Analysis, 162, 32-50.\n#'\n#' @examples\n#' b <- brown_motion(150, 50)\n#' test_results1 <- single_lag_test(b, lag = 1)\n#' test_results2 <- single_lag_test(b, lag = 2, M=100)\n#'\n#' @import stats\n#' @export\nmulti_lag_test <- function(f_data, lag = 20, M=NULL, low_disc=FALSE, iid=FALSE,\n                           alpha=0.05, suppress_raw_output=FALSE,\n                           suppress_print_output=FALSE) {\n  K <- lag\n  if (suppress_raw_output == TRUE & suppress_print_output == TRUE) {\n    stop(\"Current choice of parameters will produce no output. Atleast one of the parameters\n         'suppress_raw_output' or 'suppress_print_output' must be FALSE.\")\n  }\n  if (iid == FALSE) {\n    results <- V_WS_quantile(f_data, K, alpha=alpha, M=M, low_disc=low_disc)\n    if (suppress_print_output == FALSE) {\n      title_print <- sprintf(\" Multi-Lag Test\\n\\n\")\n      test_type <- 'the series is a weak white noise\\n'\n      null_print <- sprintf(\"null hypothesis: %s\", test_type)\n      p_val_print <- sprintf(\"p-value = %f\\n\", results$p_value)\n      samp_print <- sprintf(\"sample size = %d\\n\", NCOL(f_data))\n      lag_print <- sprintf(\"maximum lag = %d\\n\", K)\n      mc_print <- sprintf(\"number of monte-carlo simulations = %d\\n\\n\\n\", M)\n      cat(c(title_print, null_print, p_val_print, samp_print,\n            lag_print, mc_print))\n    }\n    if (suppress_raw_output == FALSE) {\n      results\n    }\n  } else {\n    results <- V_WS_quantile_iid(f_data, K, alpha=alpha)\n    if (suppress_print_output == FALSE) {\n      title_print <- sprintf(\" Multi-Lag Test (iid assumption)\\n\\n\")\n      test_type <- 'the series is a strong white noise\\n'\n      null_print <- sprintf(\"null hypothesis: %s\", test_type)\n      p_val_print <- sprintf(\"p-value = %f\\n\", results$p_value)\n      samp_print <- sprintf(\"sample size = %d\\n\", NCOL(f_data))\n      lag_print <- sprintf(\"maximum lag = %d\\n\\n\\n\", K)\n      cat(c(title_print, null_print, p_val_print, samp_print,\n            lag_print))\n    }\n    if (suppress_raw_output == FALSE) {\n      results\n    }\n  }\n}\n\n\n#' \\code{spectral_test} Computes the p-value of the size alpha spectral density based white noise\n#' test.\n#'\n#' @param f_data the functional data matrix with observed functions in the columns\n#' @param kernel the kernel function to use. The currently supported kernels are 'Bartlett', 'Parzen',\n#' and 'Daniell'. The default kernel is 'Bartlett'.\n#' @param bandwidth specifies the bandwidth to use. Currently admitted arguments are positive\n#' integers, 'static' which computes the bandwith p via p = n^(1/(2q+1)) where n is the sample\n#' size and q is the kernel order, or 'adaptive' which uses a bandwith selection method that\n#' is based on the functional data.\n#' @param alpha = the significance level to be used for the test; 0.05 by default.\n#' @param suppress_raw_output Boolean value, FALSE by default. If TRUE, the function will not return the list\n#' contining the p-value, quantile, and statistic.\n#' @param suppress_print_output Boolean value, FALSE by default. If TRUE, the function will not print any\n#' output to the console.\n#' @description The \"spectral\" portmanteau test is based on the spectral density operator. It essentially measures\n#' the proximity of a functional time series to a white noise - the constant spectral density operator of an\n#' uncorrelated series. Unlike the \"single-lag\" and \"multi-lag\" tests, this test is not for general white noise\n#' series, and may not hold under functional conditionally heterscedastic assumptions.\n#' @return A list containing the p-value, the quantile, and a boolean value indicating whether or not the\n#' hypothesis is rejected.\n#'\n#' @references\n#' Characiejus V., & Rice G. (2019). A general white noise test based on kernel lag-window estimates of the\n#' spectral density operator. Econometrics and Statistics, submitted.\n#'\n#' @examples\n#' b = brown_motion(100, 50)\n#' spectral_test(b)\n#' spectral_test(b, kernel = 'Parzen', bandwidth = 'adaptive')\n#' spectral_test(b, kernel = 'Daniell', bandwidth = 2)\n#'\n#' @export\nspectral_test <- function(f_data, kernel = 'Bartlett', bandwidth = 'adaptive', alpha = 0.05,\n                          suppress_raw_output=FALSE, suppress_print_output=FALSE) {\n  if (suppress_raw_output == TRUE & suppress_print_output == TRUE) {\n    stop(\"Current choice of parameters will produce no output. Atleast one of the parameters\n         'suppress_raw_output' or 'suppress_print_output' must be FALSE.\")\n  }\n  quantile <- qnorm(1 - alpha)\n  statistic <- spectral_t_statistic(f_data, kernel = kernel, bandwidth = bandwidth)\n  band <- statistic$band\n  statistic <- statistic$stat\n  p_val <- 1 - pnorm(statistic)\n  results <- list(statistic = statistic, quantile = quantile, p_value = p_val, band = band)\n  if (suppress_print_output == FALSE) {\n    title_print <- sprintf(\" Spectral Test\\n\\n\")\n    test_type <- 'the series is iid\\n'\n    null_print <- sprintf(\"null hypothesis: %s\", test_type)\n    p_val_print <- sprintf(\"p-value = %f\\n\", results$p_value)\n    samp_print <- sprintf(\"sample size = %d\\n\", NCOL(f_data))\n    kern_print <- sprintf(\"kernel function = %s\\n\", kernel)\n    band_print <- sprintf(\"bandwidth = %f\\n\", results$band)\n    if (is.numeric(bandwidth)) {\n      band_sel <- sprintf(\"bandwidth selection = %d\\n\\n\\n\", bandwidth)\n    } else {\n      band_sel <- sprintf(\"bandwidth selection = %s\\n\\n\\n\", bandwidth)\n    }\n    cat(c(title_print, null_print, p_val_print, samp_print, kern_print,\n          band_print, band_sel))\n  }\n  if (suppress_raw_output == FALSE) {\n    results[-4]\n  }\n}\n\n\n#' \\code{independence_test} Performs a test for independence and identical distribution of functional\n#' observations. The test relies on a dimensional reduction via a projection of the data on the K\n#' most important functional pricnipal components.\n#'\n#' @param f_data the functional data matrix with observed functions in the columns\n#' @param components the number of principal components to project the data on\n#' @param lag the maximum lag to include; this can be seen as the bandwidth.\n#' @param alpha the significance level to be used for the hypothesis test\n#' @param suppress_raw_output Boolean value, FALSE by default. If TRUE, the function will not return the list\n#' contining the p-value, quantile, and statistic.\n#' @param suppress_print_output Boolean value, FALSE by default. If TRUE, the function will not print any\n#' output to the console.\n#' @details The \"independence\" portmanteau test is a test of independence and identical distributuion based on a\n#' dimensionality reduction by projecting the data onto the most important functional principal components.\n#' It is based on the resulting lagged cross-variances. This test is not for general white noise series, and\n#' may not hold under functional conditionally heteroscedastic assumptions. Please consult the vignette for a\n#' deeper exposition, and consult the reference for a complete treatment.\n#' @return A list containing the statistic and p-value of the independence test.\n#' @references\n#' Gabrys R., & Kokoszka P. (2007). Portmanteau Test of Independence for Functional Observations.\n#' Journal of the American Statistical Association, 102:480, 1338-1348, DOI: 10.1198/016214507000001111.\n#'\n#' @examples\n#' b <- brown_motion(250, 100)\n#' independence_test(b, components = 3, lag = 5)\n#'\n#' @importFrom rainbow fts\n#' @importFrom ftsa ftsm\n#'\n#' @export\nindependence_test <- function(f_data, components, lag, alpha = 0.05,\n                              suppress_raw_output=FALSE, suppress_print_output=FALSE) {\n  if (suppress_raw_output == TRUE & suppress_print_output == TRUE) {\n    stop(\"Current choice of parameters will produce no output. Atleast one of the parameters\n         'suppress_raw_output' or 'suppress_print_output' must be FALSE.\")\n  }\n  if ((components < 1) | (components %% 1 != 0)) {\n    stop(\"The 'components parameter must be a positive integer.\")\n  }\n  if ((lag < 1) | (lag %% 1 != 0)) {\n    stop(\"The 'components lag must be a positive integer.\")\n  }\n  N <- NCOL(f_data)\n  J <- NROW(f_data)\n  f_data <- center(f_data)\n  suppressWarnings(pc_decomp <- ftsa::ftsm(rainbow::fts(1:J, f_data), order = components, mean = FALSE))\n  scores <- pc_decomp$coeff\n  C_0 <- crossprod(scores) / N\n  c_h <- array(0, dim=c(components,components,lag))\n  for (h in 1:lag) {\n    for (k in 1:components) {\n      for (l in 1:components) {\n        score_uni <- 0\n        for (t in 1:(N-h)) {\n          score_uni <- score_uni + (scores[t,k] * scores[t+h,l])\n        }\n        c_h[k,l,h] <- score_uni / N\n      }\n    }\n  }\n  r_f_h <- r_b_h <- array(0, dim=c(components,components,lag))\n  summand <- vector('numeric', lag)\n  for (h in 1:lag) {\n    r_f_h[,,h] <- solve(C_0) %*% c_h[,,h]\n    r_b_h[,,h] <- c_h[,,h] %*% solve(C_0)\n    summand[h] <- sum(r_f_h[,,h] * r_b_h[,,h])\n  }\n  Q_n <- N * sum(summand)\n  p_val <- as.numeric(1 - pchisq(Q_n, df = components^2 * lag))\n  quantile <- as.numeric(qchisq(1 - alpha, df = components^2 * lag))\n  results <- list(statistic = Q_n, quantile = quantile, p_value = p_val)\n  if (suppress_print_output == FALSE) {\n    title_print <- sprintf(\" Independence Test\\n\\n\")\n    test_type <- 'the series is iid\\n'\n    null_print <- sprintf(\"null hypothesis: %s\", test_type)\n    p_val_print <- sprintf(\"p-value = %f\\n\", results$p_value)\n    samp_print <- sprintf(\"sample size = %d\\n\", NCOL(f_data))\n    comp_print <- sprintf('number of principal components = %d\\n', components)\n    lag_print <- sprintf(\"maximum lag = %d\\n\\n\\n\", lag)\n    cat(c(title_print, null_print, p_val_print, comp_print,\n          lag_print))\n  }\n  if (suppress_raw_output == FALSE) {\n    results\n  }\n}\n",
    "created" : 1559645623169.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2816095404",
    "id" : "EFCC623D",
    "lastKnownWriteTime" : 1560213272,
    "last_content_update" : 1560213272270,
    "path" : "~/wwntests/R/main_tests.R",
    "project_path" : "R/main_tests.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 7,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}